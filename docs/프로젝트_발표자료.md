# 🎤 GigStash 프로젝트 발표 자료

## 📌 1. 프로젝트 개요

### 프로젝트명: GigStash
**행사 현장 물품 보관 서비스 관리 시스템**

### 핵심 가치
> "행사장의 짐, 이제 걱정 없이 즐기세요"

- 페스티벌, 공연, 스포츠 경기 등 대규모 행사장에서 관객들의 짐을 안전하게 보관
- 실시간 모니터링과 효율적인 운영 관리로 고객 만족도 향상
- 워커(현장 직원)와 관리자를 위한 이원화된 시스템

### 기술 스택
```
Frontend: Vue 3 (Composition API) + Pinia
Styling: Tailwind CSS + SCSS
Charts: Chart.js
Database: Firebase Firestore
Build Tool: Vite
```

---

## 💡 2. 구현 기능

### 👨‍💼 관리자 시스템 (Admin)

#### ✅ 대시보드
- 실시간 통계: 예약 현황, 매출, 보관함 상태 한눈에 파악
- 주요 지표 모니터링: 이용률, 재방문율, 배송 선택률 등
- 직관적인 카드형 UI로 정보 시각화

#### ✅ 모니터링 페이지 (핵심 기능)
- **반응형 2x2 그리드 레이아웃**: 화면 크기에 따라 자동 조정
- **4가지 핵심 차트**:
  1. 이번 달 주요 지표 (전월 대비 증감률 표시)
  2. 피크타임 분석 (맡기기/찾기 시간대별 라인 차트)
  3. 행사 유형별 매출 (막대 그래프)
  4. 사이즈별 비율 (도넛 차트)
  5. 지역별 배송 히트맵
- 다크모드 완벽 지원
- 차트 필터링 및 인터랙션

#### ✅ 예약 관리
- 예약 검색/필터링 (상태별, 날짜별, 행사별)
- 예약 상세 정보 조회 및 상태 변경
- 실시간 통계 카드 (전체/활성/대기/완료 예약 수)
- 페이지네이션 및 정렬 기능

#### ✅ 행사 관리
- 행사 등록/수정/삭제
- 행사별 예약 현황 파악
- 행사 일정 관리
- 행사별 매출 분석

### 👷 워커 시스템 (Worker)

#### ✅ 메인 대시보드
- **카카오맵 API 연동**: 행사장 위치 실시간 표시
- 오늘의 맡긴 물품 수 확인
- 빠른 QR 스캔 진입
- 내 위치 기반 네비게이션

#### ✅ QR 코드 스캔
- **html5-qrcode 라이브러리** 활용
- 실시간 카메라 스캔으로 예약 확인
- 맡기기/찾기 처리
- 스캔 히스토리 관리

#### ✅ 근무 관리
- 캘린더로 근무 일정 확인
- 급여 상세 내역 조회
- 프로필 수정 기능
- 잔여 고객 목록 확인

---

## 🎯 3. 프로젝트를 통해 배운 점

### 🔧 기술적 학습

#### Vue 3 Composition API 마스터
```javascript
// ref, computed, watch를 활용한 반응형 상태 관리
const currentDate = ref(new Date())
const filteredData = computed(() => {
  return data.value.filter(item => item.date === currentDate.value)
})
```
**배운 것:**
- `<script setup>` 문법으로 더 간결한 컴포넌트 작성
- Composables 패턴으로 로직 재사용
- 타입 추론이 자연스럽고 IDE 지원 우수

**활용 사례:**
- useDarkMode() - 다크모드 전환 로직 재사용
- 차트 데이터 계산 로직을 computed로 최적화

#### Pinia를 통한 전역 상태 관리
```javascript
export const useAuthStore = defineStore('auth', {
  state: () => ({
    user: null,
    isAuthenticated: false
  }),
  actions: {
    async login(email, password) { /* ... */ },
    logout() { /* ... */ }
  }
})
```
**배운 것:**
- Vuex보다 직관적이고 TypeScript 친화적
- 액션에서 직접 state 변경 가능 (mutations 불필요)
- DevTools 연동으로 디버깅 용이

**활용:**
- 사용자 인증 상태 관리
- 예약 데이터 캐싱 및 동기화
- 다크모드 설정 전역 관리

#### Chart.js 커스터마이징 및 반응형 구현
```javascript
const chartOptions = {
  responsive: true,
  maintainAspectRatio: false,
  plugins: {
    legend: { display: false },
    tooltip: { /* 커스텀 툴팁 */ }
  }
}
```
**배운 것:**
- 다크모드 대응을 위한 동적 색상 변경
- 커스텀 툴팁 및 범례 디자인
- 반응형 차트 높이 조정 테크닉

**어려웠던 점과 해결:**
- 문제: 차트가 부모 컨테이너 높이를 따르지 않음
- 해결: `flex-1 min-h-0` + `position: relative; height: 100%` 조합
- 결과: 화면 크기에 따라 차트가 완벽하게 반응

#### Tailwind CSS + SCSS 하이브리드 활용
**Tailwind CSS:**
- 유틸리티 클래스로 빠른 UI 개발
- 일관된 디자인 시스템 유지
- 다크모드 클래스 (`dark:`) 활용

**SCSS:**
- 복잡한 애니메이션 및 트랜지션
- 전역 CSS 변수 관리
- 커스텀 스크롤바 스타일링

**배운 것:**
- 적재적소에 맞는 스타일링 방법 선택
- Tailwind 설정 커스터마이징 (색상, 브레이크포인트)

#### Firebase Firestore 실전 활용
```javascript
// 복잡한 쿼리 작성 및 최적화
const q = query(
  collection(db, 'reservations'),
  where('eventId', '==', eventId),
  where('status', 'in', ['active', 'pending']),
  orderBy('createdAt', 'desc'),
  limit(20)
)
const snapshot = await getDocs(q)
```
**배운 것:**
- NoSQL 데이터 모델링 (비정규화 전략)
- Firestore 쿼리 제약사항 이해 및 우회
- 복합 인덱스 생성 및 관리
- 페이지네이션 구현 (startAfter, limit)

**최적화:**
- 불필요한 읽기 요청 최소화
- 클라이언트 측 캐싱 활용
- 쿼리 결과를 Pinia에 저장하여 재사용

### 🤝 협업 및 문제 해결

#### Git 브랜치 전략 및 협업 경험
- **브랜치 전략:**
  - `main`: 프로덕션 배포 브랜치
  - `develop`: 개발 통합 브랜치
  - `feature/*`: 기능별 개발 브랜치

- **Pull Request 프로세스:**
  - 코드 리뷰를 통한 품질 관리
  - 충돌 해결 경험
  - 커밋 메시지 컨벤션 준수

#### 반응형 레이아웃 설계 경험
**고민했던 점:**
- Mobile First vs Desktop First 접근 방식
- 브레이크포인트 설정 기준

**적용한 전략:**
- Desktop First로 설계 (관리자 시스템 특성상)
- `lg:` (1024px) 브레이크포인트 중심 대응
- Flexbox와 Grid를 상황에 맞게 선택

**배운 것:**
- Flexbox: 1차원 레이아웃, 유연한 공간 분배
- Grid: 2차원 레이아웃, 복잡한 레이아웃 구조
- `min-h-0`, `flex-1`의 중요성

#### 디버깅 능력 향상
**활용한 도구:**
- Vue Devtools: 컴포넌트 상태 및 Pinia 스토어 추적
- Chrome DevTools Network: Firebase 요청 모니터링
- Console 로깅을 최소화하고 Breakpoint 활용

**체계적 디버깅 프로세스:**
1. 문제 재현 및 범위 좁히기
2. Vue Devtools로 상태 확인
3. 네트워크 탭으로 API 응답 확인
4. Breakpoint로 코드 흐름 추적

---

## 😓 4. 아쉬운 점

### 기술적 아쉬움

#### 1. 테스트 코드 부족
**현재 상황:**
- Vitest 설정은 완료했지만 테스트 미작성
- 수동 테스트에만 의존

**문제점:**
- 리팩토링 시 불안감
- 회귀 버그 발견이 늦어짐
- 코드 품질 보증 부족

**작성하지 못한 테스트 예시:**
```javascript
describe('MonitoringView', () => {
  it('should render charts correctly', () => {})
  it('should filter data by date range', () => {})
  it('should toggle dark mode', () => {})
})
```

#### 2. 컴포넌트 재사용성 부족
**문제:**
- MonitoringView.vue가 1700줄 이상으로 비대화
- 차트 설정 코드가 중복됨
- 유지보수 어려움

**개선 방향:**
```
components/
  charts/
    ComBarChart.vue
    ComLineChart.vue
    ComDoughnutChart.vue
    ComChartContainer.vue
```

#### 3. 성능 최적화 미흡
**문제 사례:**
```javascript
// 매번 전체 데이터를 필터링
const filteredReservations = computed(() => {
  return allReservations.value.filter(/* 복잡한 조건 */)
})
```

**발생한 이슈:**
- 대량 데이터(500+ 예약) 처리 시 렌더링 지연
- 차트 업데이트 시 프레임 드롭

**개선 방향:**
- 가상 스크롤링 (Virtual Scrolling)
- 페이지네이션 강화
- 메모이제이션 활용
- Web Worker로 무거운 계산 분리

#### 4. TypeScript 미사용
**현재 상황:**
- JavaScript만 사용
- 타입 관련 런타임 에러 발생

**발생한 문제:**
```javascript
// 예상치 못한 undefined 에러
const userName = user.name.toUpperCase()
// TypeError: Cannot read properties of undefined
```

**아쉬움:**
- IDE 자동완성 제한적
- 리팩토링 시 실수 가능성 높음
- 타입 안정성 부족

### 설계 및 기획 아쉬움

#### 1. 실시간 업데이트 미구현
**현재 방식:**
- 페이지 로드 시 한 번만 데이터 가져옴
- 수동 새로고침 필요

**개선 방향:**
```javascript
// Firebase onSnapshot으로 실시간 동기화
onSnapshot(collection(db, 'reservations'), (snapshot) => {
  snapshot.docChanges().forEach((change) => {
    if (change.type === 'added') {
      // 새 예약 알림
    }
  })
})
```

#### 2. 접근성(Accessibility) 고려 부족
**문제점:**
- 키보드 네비게이션 미지원
- 스크린 리더 최적화 안 됨
- ARIA 속성 미적용
- 포커스 관리 부족

**개선 필요:**
```html
<!-- 현재 -->
<button @click="handleClick">버튼</button>

<!-- 개선 -->
<button
  @click="handleClick"
  aria-label="예약 삭제"
  :aria-pressed="isActive"
>
  버튼
</button>
```

#### 3. 에러 핸들링 부족
**현재 코드:**
```javascript
const data = await fetchData()
```

**개선 필요:**
```javascript
try {
  const data = await fetchData()
  // 성공 처리
} catch (error) {
  // 사용자에게 친절한 에러 메시지
  showToast('데이터를 불러오는데 실패했습니다.')
  // 에러 로깅 (Sentry 등)
  logError(error)
  // 기본값 설정
  return defaultData
}
```

#### 4. 문서화 부족
- 컴포넌트 Props/Emits 문서화 없음
- API 함수 JSDoc 주석 부족
- README에 설치/실행 가이드만 존재

---

## 🚀 5. 향후 개선 방향

### 🎯 단기 개선 (1-2개월)

#### ✅ TypeScript 마이그레이션
**목표:** 타입 안정성 확보, 개발자 경험 향상

**마이그레이션 계획:**
```typescript
// 1단계: 타입 정의 작성
interface Reservation {
  id: string
  customerId: string
  lockerId: string
  status: 'pending' | 'active' | 'completed' | 'cancelled'
  createdAt: Timestamp
  updatedAt: Timestamp
}

// 2단계: 컴포넌트 Props 타입 정의
interface Props {
  reservations: Reservation[]
  onUpdate?: (id: string) => void
}

// 3단계: 점진적 마이그레이션
// .js → .ts 파일 변환
```

**기대 효과:**
- 런타임 에러 80% 감소
- IDE 자동완성 개선
- 리팩토링 시 안정성 향상

#### ✅ 테스트 코드 작성
**목표:** 코드 커버리지 80% 이상

**테스트 전략:**
```javascript
// Unit Test (Vitest)
describe('useAuthStore', () => {
  it('should login successfully', async () => {
    const store = useAuthStore()
    await store.login('test@test.com', 'password')
    expect(store.isAuthenticated).toBe(true)
  })
})

// Component Test
describe('ComButton', () => {
  it('should emit click event', () => {
    const wrapper = mount(ComButton)
    wrapper.find('button').trigger('click')
    expect(wrapper.emitted('click')).toBeTruthy()
  })
})

// E2E Test (Playwright)
test('admin can view monitoring dashboard', async ({ page }) => {
  await page.goto('/admin/monitoring')
  await expect(page.locator('h2')).toContainText('이번 달 주요 지표')
})
```

#### ✅ 성능 최적화
**1. 이미지 최적화**
- WebP 포맷 사용
- Lazy Loading 적용
- CDN 활용

**2. 코드 스플리팅**
```javascript
// 라우트별 청크 분리
const MonitoringView = defineAsyncComponent(() =>
  import('@/pages/admin/MonitoringView.vue')
)
```

**3. Firebase 쿼리 최적화**
- 복합 인덱스 생성
- 페이지네이션 강화
- 클라이언트 측 캐싱

**4. 컴포넌트 지연 로딩**
```javascript
const HeavyChart = defineAsyncComponent({
  loader: () => import('@/components/HeavyChart.vue'),
  loadingComponent: LoadingSpinner,
  delay: 200
})
```

#### ✅ 접근성 개선
**목표:** WCAG 2.1 AA 수준 준수

**개선 항목:**
- 키보드 네비게이션 (Tab, Enter, Esc)
- ARIA 속성 추가
- 색상 대비 개선 (4.5:1 이상)
- 포커스 표시 명확화
- 스크린 리더 테스트

### 🔄 중기 개선 (3-6개월)

#### 📡 실시간 기능 추가
**구현 계획:**
```javascript
// Firebase onSnapshot으로 실시간 동기화
const unsubscribe = onSnapshot(
  collection(db, 'reservations'),
  (snapshot) => {
    snapshot.docChanges().forEach((change) => {
      if (change.type === 'added') {
        showNotification('새 예약이 접수되었습니다.')
      }
      if (change.type === 'modified') {
        updateReservationInStore(change.doc.data())
      }
    })
  }
)
```

**추가 기능:**
- 워커 앱: 새 예약 알림 푸시
- 관리자: 실시간 통계 자동 업데이트
- 채팅 기능으로 워커-관리자 소통
- WebSocket 대신 Firebase Cloud Messaging 활용

#### 📱 PWA 전환
**목표:** 앱스토어 없이 설치 가능, 오프라인 지원

**구현:**
```javascript
// manifest.json
{
  "name": "GigStash",
  "short_name": "GigStash",
  "start_url": "/",
  "display": "standalone",
  "background_color": "#ffffff",
  "theme_color": "#3482FF",
  "icons": [
    {
      "src": "/icon-192.png",
      "sizes": "192x192",
      "type": "image/png"
    }
  ]
}

// Service Worker
self.addEventListener('fetch', (event) => {
  event.respondWith(
    caches.match(event.request)
      .then(response => response || fetch(event.request))
  )
})
```

**장점:**
- 앱스토어 등록 불필요
- 오프라인에서도 기본 기능 동작
- 푸시 알림 지원
- 빠른 로딩 속도

#### 📊 고급 분석 기능
**1. 머신러닝 기반 수요 예측**
- 과거 데이터 기반 예약 수요 예측
- 행사별 최적 보관함 개수 추천

**2. 고객 행동 패턴 분석**
- RFM 분석 (Recency, Frequency, Monetary)
- 코호트 분석
- 사용자 세그먼트 분류

**3. 대시보드 커스터마이징**
- 관리자가 원하는 차트 선택
- 드래그 앤 드롭으로 레이아웃 변경
- 커스텀 리포트 생성

#### 🔐 보안 강화
**1. Firebase Security Rules 강화**
```javascript
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    match /reservations/{reservation} {
      allow read: if request.auth != null;
      allow write: if request.auth.token.admin == true;
    }
  }
}
```

**2. 인증 개선**
- JWT 토큰 자동 갱신
- Refresh Token 구현
- 다중 인증 (MFA) 지원

**3. 보안 헤더 적용**
- HTTPS 강제
- CSP (Content Security Policy)
- CORS 정책 강화

### 🌟 장기 비전 (6개월 이상)

#### 🌐 다국어 지원 (i18n)
**목표:** 해외 시장 진출 준비

**구현:**
```javascript
// vue-i18n 설정
const i18n = createI18n({
  locale: 'ko',
  fallbackLocale: 'en',
  messages: {
    ko: { /* 한국어 */ },
    en: { /* 영어 */ },
    ja: { /* 일본어 */ }
  }
})

// 사용
const { t } = useI18n()
<h1>{{ t('monitoring.title') }}</h1>
```

**지원 언어:**
- 한국어 (기본)
- 영어
- 일본어
- 중국어

#### 🤖 AI 챗봇 고객 지원
**기능:**
- 예약 관련 FAQ 자동 응답
- 분실물 찾기 보조
- 자연어로 데이터 조회
- OpenAI API 또는 Claude API 활용

**예시:**
```
사용자: "오늘 예약이 몇 건이에요?"
AI: "오늘 총 47건의 예약이 있으며,
     현재 활성 예약은 23건입니다."
```

#### 📦 마이크로서비스 아키텍처
**현재:**
- Monolithic Vue App
- 모든 기능이 하나의 앱에 존재

**개선:**
```
gigstash-frontend (Vue)
├── admin-app (관리자 전용)
├── worker-app (워커 전용)
└── customer-app (고객용 예약 앱)

gigstash-backend (Node.js/Express)
├── auth-service
├── reservation-service
├── analytics-service
└── notification-service
```

**장점:**
- 독립 배포 가능
- 서비스별 확장성
- 장애 격리
- 팀별 개발 효율 증가

#### 🎯 비즈니스 확장
**1. B2B SaaS 모델**
- 다른 행사장에 서비스 제공
- 구독 기반 요금제
- 화이트 라벨링 지원

**2. API 제공**
- 외부 티켓팅 시스템 연동
- REST API / GraphQL 제공
- API 문서 자동 생성 (Swagger)

**3. 모바일 앱 개발**
- React Native 또는 Flutter
- iOS / Android 네이티브 앱
- 고객용 예약 앱 출시

---

## 💭 6. 결론

### 프로젝트를 통해 느낀 점

**"완벽한 코드는 없다, 계속 개선하는 코드만 있다"**

이 프로젝트를 진행하며 가장 크게 느낀 점은, 실무 프로젝트는 단순히 기능을 구현하는 것을 넘어서 성능, 접근성, 유지보수성, 사용자 경험까지 모든 것을 고려해야 한다는 것입니다.

**기술보다 중요한 것은 사용자 경험(UX)**

아무리 최신 기술을 사용해도, 사용자가 불편하면 의미가 없습니다. 워커 분들이 현장에서 빠르게 QR을 스캔할 수 있도록, 관리자가 한눈에 통계를 파악할 수 있도록 UI/UX에 많은 시간을 투자했습니다.

### 기술적 성장

1. **Vue 3 생태계 전반 이해**
   - Composition API, Pinia, Vue Router 마스터
   - Composables 패턴으로 로직 재사용
   - 반응형 시스템의 깊은 이해

2. **상태 관리의 중요성 체득**
   - 전역 상태와 로컬 상태 구분
   - 불필요한 리렌더링 최소화
   - 데이터 흐름 단방향 유지

3. **반응형 UI 설계 경험**
   - 모바일/태블릿/데스크톱 대응
   - Flexbox와 Grid의 적절한 사용
   - 다크모드 완벽 지원

4. **Firebase 실전 활용 능력**
   - NoSQL 데이터 모델링
   - 쿼리 최적화 및 인덱싱
   - 보안 규칙 설정

### 향후 개발자로서의 목표

1. **품질:** 테스트 코드 작성 습관화
2. **성능:** 프로파일링 도구 활용한 최적화
3. **협업:** 코드 리뷰 문화 정착
4. **학습:** TypeScript, Nuxt 3, Next.js 심화 학습
5. **기여:** 오픈소스 프로젝트 기여

### 감사 인사

이 프로젝트를 함께 진행한 팀원들, 그리고 피드백을 주신 모든 분들께 감사드립니다.

---

## 📎 부록: 발표 시연 포인트

### 데모 시연 순서

1. **관리자 로그인** (30초)
   - 로그인 프로세스 간단히 보여주기
   - 대시보드 첫 화면 설명

2. **모니터링 페이지** (3분)
   - 반응형 레이아웃 (브라우저 크기 조절)
   - 다크모드 토글 시연
   - 차트 인터랙션 (호버, 필터링)
   - 날짜 범위 변경 시 차트 업데이트

3. **예약 관리** (2분)
   - 예약 검색 및 필터링
   - 예약 상세 조회
   - 상태 변경 시연

4. **워커 앱** (2분)
   - QR 코드 스캔 시연
   - 카카오맵 위치 확인
   - 캘린더에서 근무 일정 확인

5. **반응형 확인** (1분)
   - 모바일 뷰 전환
   - 태블릿 레이아웃 확인

### 강조할 점

✅ **실제 사용 가능한 수준의 완성도**
- 프로토타입이 아닌 실제 배포 가능한 서비스

✅ **세심한 UI/UX**
- 로딩 상태 표시
- 에러 처리 및 피드백
- 직관적인 네비게이션

✅ **다크모드 완벽 지원**
- 모든 페이지에서 일관된 다크모드
- 색상 대비 고려

✅ **모바일/데스크톱 반응형**
- 모든 디바이스에서 최적화된 경험
- 터치 인터랙션 지원

### 예상 질문 및 답변

**Q: 왜 Vue를 선택했나요?**
A: React와 비교했을 때, Vue의 학습 곡선이 완만하고 템플릿 문법이 직관적이어서 팀 전체가 빠르게 적응할 수 있었습니다. 또한 Composition API는 React Hooks와 유사하면서도 더 명시적이라고 느꼈습니다.

**Q: Firebase를 사용한 이유는?**
A: 백엔드를 별도로 구축하는 대신 Firebase를 사용해 개발 속도를 높이고, 실시간 동기화와 인증 기능을 쉽게 구현할 수 있었습니다. 초기 스타트업에 적합한 선택이었습니다.

**Q: 가장 어려웠던 부분은?**
A: Chart.js를 사용해 반응형 차트를 구현하는 것이 가장 어려웠습니다. 특히 다크모드 전환 시 차트 색상을 동적으로 변경하고, 부모 컨테이너 높이에 맞춰 차트가 자동으로 조정되도록 만드는 과정에서 많은 시행착오가 있었습니다.

**Q: 성능 이슈는 없었나요?**
A: 초기에는 대량 데이터 렌더링 시 지연이 있었습니다. 이를 페이지네이션과 가상 스크롤링으로 해결했고, Firebase 쿼리를 최적화해 읽기 비용을 줄였습니다.

**Q: 실제 배포 계획은?**
A: Vercel이나 Netlify를 통해 프론트엔드를 배포하고, Firebase Hosting을 백업으로 사용할 계획입니다. CI/CD는 GitHub Actions로 자동화할 예정입니다.

---

## 📊 프로젝트 통계

### 개발 기간
- **총 개발 기간**: 8주
- **주요 기능 개발**: 6주
- **테스트 및 버그 수정**: 2주

### 코드 통계
```
총 라인 수: ~15,000줄
  - Vue 컴포넌트: ~8,000줄
  - JavaScript: ~4,000줄
  - SCSS/CSS: ~2,000줄
  - 설정 파일: ~1,000줄

컴포넌트 수: 24개
  - Admin: 15개
  - Worker: 9개

페이지 수: 12개
  - Admin: 4개
  - Worker: 8개
```

### 기술 스택 버전
```
Vue: 3.5.22
Pinia: 3.0.3
Vue Router: 4.6.3
Chart.js: 4.5.1
Firebase: 11.10.0
Tailwind CSS: 3.4.18
Vite: 7.1.11
```

---

**발표 시간 목표: 10-15분**
**발표자: [이름]**
**발표일: [날짜]**
